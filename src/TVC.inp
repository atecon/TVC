function scalar Crit (matrix *g "variance ratios",
                      const matrix X "observations",
                      const matrix XX "matrix X'X",
                      const matrix y "vector of dependent variable",
                      const matrix Xy "right-hand side of normal equation",
                      const matrix P "difference matrix",
                      const scalar T "number of observations",
                      const scalar n "number of regressors",
                      const bool use_likelihood "likelihood",
                      const bool print_details[FALSE])

    # This gives the negatively signed criterion function (equations 3.12 for
    # likelihood and 3.13 for moments estimation), stripped of constants and
    # re-parametrized in terms of variance variance_ratios and the sum of squares Q
    # instead of variances, using equation 3.9 -- see Appendix B in the
    # documentation. Default is moments estimation. Likelihood estimation
    # is performed if the flag "use_likelihood" is true.

    matrix M = XX
    matrix G = zeros(n, n)
    G[diag] = 1 ./ g
    G = I(T-1)**G
    matrix M += qform(P', G)

    matrix a = M \ Xy
    matrix u = y - X * a
    matrix v =P * a

    # Construct criterion, as in equation (3.13), but negatively signed
    # because a maximization (rather than a minimization) routine is
    # employed.

    if use_likelihood
        M = qform(P, M)
    endif

    scalar crit = -ldet(M) - (T-1) * sum(log(g)) \
                  -(T - n * !use_likelihood) \
                  * log(u'u + qform(v', G))

    if print_details
        # step monitor prints current state of calculations
        printf "Variance variance_ratios: "
        loop i=1..n
            printf "%10g ", g[i]
        endloop
        printf "           \r"
        flush
    endif

    return crit
end function


function matrix makeX (const matrix x "regressor matrix",
                       const scalar T "number of obs")
    # create matrix X, see section 2.3

    matrix X = {}

    loop i=1..T
        X = diagcat(X, x[i,])
    endloop

    return X
end function

function matrix makeP (const scalar T "number of observations",
                       const scalar n "number of regressors")
    # create matrix P, see section 2.3

    matrix p = zeros(T-1, T)

    loop i=1..(T-1)
        p[i,i] = -1
        p[i,i+1] = 1
    endloop
    matrix P = p**I(n)

    return P
end function


function matrix makeBounds (matrix *g,
                            const scalar n)
    # This function creates a matrix "bounds" that that gives
    # rows {i,lb, ub} for each regressor where i is the index
    # of the regressor, lb is the lower bound for the coefficient
    # of the regressor i and ub gives its upper bound of regressor.
    # the matrix is used by the BFGScmax function.
    # Determine the matrix bounds using g

    matrix bounds = {}
    loop i=1..n
        if g[i,1] > 0
            bounds |= {i, 0, $huge}
        elif g[i,1] == 0
            bounds |= {i, 1e-7, 1e-7}
            g[i,1] = 1e-7
        elif g[i,1] < 0
            bounds |= {i, -g[i,1], -g[i,1]}
            g[i,1] = -g[i,1]
        endif
    endloop

    return bounds
end function


function scalar LogLike (const bundle self,
                         const matrix x "regressor matrix",
                         const matrix y "dependent variable",
                         const matrix X "big regressor matrix",
                         const matrix P "lag matrix")
    # computes the log-likelihood function eq. (3.10)

    matrix G = zeros(self.ncoeff, self.ncoeff)
    G[diag] = self.g
    G = I(self.T-1)**G
    matrix W = X * P'inv(P*P')
    W = self.sigma * (qform(W, G) + I(self.T))
    scalar LL = -0.5 * (self.T * (log(2) + log($pi) ) + ldet(W) )

    matrix m = (y - x * self.coeff_average)
    LL += -0.5 * m'inv(W) * m

    return LL
end function


function bundle getDefaults (const int nfeatures "number regressors")
    /* Get default values. */

    bundle self = empty

    matrix self.g = ones(nfeatures)  # variance ratios
    scalar self.plot_results = TRUE
    scalar self.use_likelihood = FALSE

    # for printout
    scalar self.print_details = FALSE
    scalar self.silent = FALSE
    scalar self.width = 20
    scalar self.width1 = 30
    scalar self.width2 = 20
    scalar self.precision = 4

    return self
end function


function bundle TVCestimate (series target "dependent variable",
                             list features "regressors",
                             const bundle opts[null] "Options")
    /* Main function for estimating the model.

    Symbols correspond to the symbols used in in Schlicht (2021),
    Journal of the Korean Statistical  Society 50, 1164â€“1196.
    URL: https://doi.org/10.1007/s42952-021-00110-y
    Bracketed numbers in comments refer to equation numbers therein.
    */
    set max_verbose off

    list TargetFeatures = target features
    errorif(sum(missing(TargetFeatures)) > FALSE,
            "Some observations have missing values. \nPlease correct.")

    matrix y = {target}
    matrix x = {features}
    scalar T = rows(x)
    scalar n = cols(x)

    bundle self = getDefaults(n)
    if exists(opts)
        bundle self = opts + self
    endif

    scalar self.T = T
    scalar self.t1 = $t1
    scalar self.t2 = $t2
    scalar self.ncoeff = n
    matrix self.g = vec(self.g)

    errorif(rows(self.g) != self.ncoeff,
            sprintf("The number of variance variance_ratios must equal the \n\
                    number of regressors. Please correct."))

    string self.depvar = argname(target)
    strings self.parnames = varnames(features)


    matrix self.g0 = self.g  # g0: initial variance
    matrix g = self.g        # filtered variance
    # The following matrices are created here and handed over as constants
    # to the criterion function to avoid repeated calculation.

    matrix X = makeX(x, self.T)   # observations
    matrix XX = X'X
    matrix Xy = X'y               # right-hand side of normal equation
    matrix P = makeP(self.T, self.ncoeff)   # difference matrix
    matrix bounds = makeBounds(&g, self.ncoeff)

    # find variance variance_ratios g that maximize the criterion function Crit
    scalar C = BFGScmax(&g, bounds, Crit(&g, X, XX, y, Xy, P, self.T, self.ncoeff,
                                         self.use_likelihood, self.print_details))
    self.g = g

    # prepare output
    matrix M = XX
    matrix G = zeros(self.ncoeff, self.ncoeff)
    G[diag] = 1 ./ self.g
    G = I(self.T - 1) ** G
    matrix M += qform(P', G)
    matrix iM = inv(M)
    matrix self.coeff = iM * Xy            # point estimates
    matrix u = y - X * self.coeff
    matrix v = P * self.coeff
    scalar Q = u'u + qform(v', G)
    scalar self.sigma = Q / (self.T - self.ncoeff)  # variance
    self.stderr = self.sigma * diag(iM)
    self.stderr = sqrt(self.stderr)        # standard errors
    self.vcv = self.sigma * iM

    matrix self.coeff = mshape(self.coeff, self.ncoeff, self.T)'
    matrix self.stderr = mshape(self.stderr, self.ncoeff, self.T)'
    matrix self.coeff_average = meanc(self.coeff)'
    cnameset(self.coeff, self.parnames)
    cnameset(self.stderr, self.parnames)
    rnameset(self.coeff_average, self.parnames)

    scalar self.lnl = LogLike(self, x, y, X, P)

    # Create and add to bundle fitted in-sample values and residuals
    series self.yhat_average = lincomb(features, self.coeff_average)
    series self.yhat = sumr(x .* self.coeff)
    series self.uhat = target - self.yhat
    series self.uhat_average = target - self.yhat_average
    scalar self.ess = sst(self.uhat)
    scalar self.rsq = mcorr({self.yhat, target})[1,2]^2

    if self.silent == FALSE
        print_results(self)
    endif

    cleanup_bundle(&self)

    return self
end function


# TODO: Make plot storeable
function void plotTVC (const bundle self, const string filename[null])
    /* Wrapper function calling TVCplots package. */

    list Input = empty  # bhat(x1)~stderr(x1)~bhat(x2)~stderr(x2)~...
    smpl self.t1 self.t2  # catch eventual missing values

    loop i=1..self.ncoeff
        Input += genseries(sprintf("b_%s", self.parnames[i]), self.coeff[,i])
        Input += genseries(sprintf("stderr_%s", self.parnames[i]), self.stderr[,i])
    endloop

    TVCplots(Input,,,,,,0,0)
end function


function list getTVCcoeffs (const bundle self,
                            string prefix[null])
    /* Retrieve the time-varying coefficient estimates.

    Parameters:
    self (bundle): The Gretl model object.
    prefix (string, optional): A prefix to be added to the names of the
        output series. If not provided, no prefix will be used.

    Returns:
    list: A list of Gretl series containing the time-varying coefficient
        estimates. The series names will be constructed by concatenating
        the provided prefix (if any) and the series names.
    */

    string prefix = exists(prefix) ? prefix : ""
    list Ret = empty
    smpl self.t1 self.t2  # catch eventual missing values

    loop i=1..self.ncoeff
        list Ret += genseries(sprintf("%s%s", prefix, self.parnames[i]),
                              self.coeff[,i])
    endloop

    return Ret
end function

function list getTVCstderr (const bundle self,
                            string prefix[null])
    /* Retrieve the time-varying standard error.

    Parameters:
    self (bundle): The Gretl model object.
    prefix (string, optional): A prefix to be added to the names of the
        output series. If not provided, prefix "stderr_" will be used.

    Returns:
    list: A list of Gretl series containing the time-varying standard
        errors. The series names will be constructed by concatenating
        the provided or default prefix and the series names.
    */

    string prefix = exists(prefix) ? prefix : "stderr_"
    list Ret = empty
    smpl self.t1 self.t2  # catch eventual missing values

    loop i=1..self.ncoeff
        list Ret += genseries(sprintf("%s%s", prefix, self.parnames[i]),
                              self.stderr[,i])
    endloop

    return Ret
end function

function void cleanup_bundle (bundle *self)
    /* Remove some of the bundle items. */

    delete self.precision
    delete self.width
    delete self.width1
    delete self.width2
end function


function void print_results (const bundle self)
    /* Print estimation results. */

    printf "\n\nResults of Time-Varying Coefficients Estimation"
    printf "\n===============================================\n"
    printf "\nDependent variable: %s\n", self.depvar

    printf "Regressors: "
    loop foreach i self.parnames
        printf "%s ", "$i"
    endloop

    printf "\n\n%*svariances", (self.width1 - 9), " "
    printf "%*sinitial", (self.width2 - 7) , " "
    printf "%*sfiltered with\n", (self.width2 - 13), " "
    printf "%*svariance ratios", (self.width1 + self.width2 - 15), " "
    printf "%*svariance ratios", (self.width2 - 15), " "
    printf "\nequation%*.*g", (self.width1 - 8), self.precision, self.sigma

    loop foreach i self.parnames
        width = self.width1 - strlen(self.parnames[i])
        printf "\n%s", "$i"
        printf "%*.*g", width, self.precision, self.g[i] * self.sigma
        printf "%*.*g", self.width2, self.precision, self.g0[i]
        printf "%*.*g", self.width2, self.precision, self.g[i]
    endloop
    printf "\n"

    printf"\naverage coefficients\n"
    loop foreach i self.parnames
        width = 20 - strlen(self.parnames[i])
        printf "%s%*s%10.4f\n", self.parnames[i], width, " ",
            self.coeff_average[i]
    endloop


    printf "\n"
    if (!(self.g0 > zeros(self.ncoeff)))  # TODO: Is this condition correcz?
        loop i=1..self.ncoeff
            if self.g0[i] == 0
                printf "\nCoefficient for %s is treated as time-invariant",
                    self.parnames[i]
            elif self.g0[i] < 0
                printf "\nVariance ratio for %s is fixed as %g",
                    self.parnames[i], abs(self.g0[i])
            endif
        endloop
        printf "\n"
    endif

    scalar nparams = 1
    if (!(min(self.g0) < 0))
        loop i=1..self.ncoeff
            if self.g0[i] > 0
                nparams += 2
            elif self.g0[i] == 0
                nparams += 1
            endif
        endloop
    endif

    printf "Number of observations: %g\nNumber of regressors: %g\n",
        self.T, self.ncoeff

    if (!(min(self.g0) < 0))
        printf "Number of estimated parameters: %g\n", nparams
    endif

    if self.use_likelihood
        printf "Estimation method: maximum likelihood estimator\n"
    else
        printf "Estimation method: moments estimator\n"
    endif
    printf "Log likelihood: %g", self.lnl
    printf " (Presupposes Gaussian disturbances throughout.)\n"

    if self.use_likelihood
        printf "\tYou have chosen maximum likelihood estimation.\n"
        printf "\tThis is not recommended because it tends to produce \n"
        printf "\tcorner solutions - extreme values for the variance \n"
        printf "\tratios and the variance - in shorter time series.\n\n"
    endif
end function

